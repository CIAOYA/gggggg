# &#x20;03-08

*   结构体与指针

    *   结构体

        *   由数据元素组成的结构,它是一个很有用的编程构件,一系列具有指定数据类型的数据字段,能够通过单个变量引用一系列相关的值,通过使用结构体,可在单个变量中存储众多类型不同的数据字段,存储在结构体中可轻松的访问和修改,提高模块化程度,创建传递复杂的数据结构
        *   声明并创建结构体

            *   type Movie struct{ Name string    Rating float32 }

                *   关键字type指定一种新类型,名为Movie,而类型名右边是为结构体的数据类型
                *   大括号内为使用名称和类型指定的一系列未赋值的数据字段
                    *   func函数: m := Movie {Name: "电棍" , Rating: 10,}

                        *   在func函数中,声明并初始化变量m,给数据字段指定的值为相应的数据类型
            *   声明结构体后可直接声明这种类型的变量
                *   调查或查看结构体的值,如果没有初始化则设置为相应数据类型的零值:
                    *   fmt.Printf("%+v\n",m)
                *   默认零值的情况可使用点表示法给其字段赋值
                    *   var m Movir  m.Name="电棍"  m.Rating=10
        *   结构体数据字段是可变的,可动态的修改它们
        *   也可使用关键字new创建结构体实例
            *   func函数内: m := new(Movie)  m.Name="otto" m.Ratring=10
        *   推荐使用→简短变量赋值创建结构体实例
            *   func函数内: m := Movie{Name:"电棍" , Rating :10}
                *   可省略字段名,按字段声明顺序赋值,不过不推荐
                    *   m := Movie{"电棍",10}
            *   注:字段很多时,让每个字段独占一行能提高代码的可维护性和可读性,如果这样做,最后一个数据字段所在的行也必须逗号结尾
                *   m:=Moive{Name:"otto",Rating:10,}
        *   嵌套结构体
            *   当数据结构需要包含多个层级或建立复杂的数据结构,可以使用嵌套结构体,也就是在一个结构体中嵌套另一个结构体,嵌套没有层数限制,但嵌套层级太多,可能使用其他数据结构是更好的选择
            *   例:前提:超级英雄列表,第一个声明了名字年龄住址,第二个声明住址的号码城市等
                *   func函数中: e := Superhero{Name:"Batman",Age:32,Address\:Address {Number:1007,Street:"Mountain Drive",City:"Gotham", }, }
                    *   在Address中嵌套了第二个结构体,赋值了住址的详细信息
        *   自定义结构体的默认值
            *   布尔false,整型0,浮点0.0,字符串"" ,其他都是nil
        *   比较结构体
            *   对结构体进行比较,要先看它们的类型和值是否相同,对相同的用==与!=这类相等性运算符比较,而确认类型相同可使用reflect包
                *   教材中fmt.Printf(reflect.TypeOf(a))似乎出错,不过可以先创建TypeOfA来接受reflect.TypeOf(a),然后输出得到结果
        *   公有和私有值
            *   一个值被导出可在函数方法或包外使用便是公有,只能在其所属上下文使用便是私有
        *   指针引用和值引用
            *   指针引用
                *   包含值的内存地址,可读写存储的值,修改b会将修改分配给a的内存,获得指针在变量名前加上和&号
                    *   例 b := \&a
            *   值引用
                *   赋值,相同但不是指向b的引用,修改b不会影响a,反之亦然
                    *   b := a
    *   创建方法和接口
        *   使用方法
            *   方法类型与函数,但在关键字func后面添加了另一个参数部分,用于接受单个参数
                *   例: func (m\*Movie) summary() string{ //code }
                    *   而func后面多了个参数为接收者,严格来说接收者是一种类型,这里是指向结构体Movie的指针,接下来是方法名summary,参数(),返回类型string
                    *   可将接收者视为与方法相关联的东西
                    *   通过声明方法summary,让结构体Movie的任何实例都可使用它,而使用方法不使用函数时因为函数与结构体相互依赖但没有直接关系,不访问Movie的定义就不能声明函数summary,如果使用函数则在每个使用函数和结构体的地方都需包含其定义,这会导致代码重复
                        *   并且函数发生改变,要修改多个地方时,也是使用方法更合理,只需编写方法实现一次,就可对结构体的任何实例进行调用
            *   创建方法集
                *   方法集是可对特定数据类型进行调用的一组方法,任何数据类型都可有相关联的方法集,能够在数据类型和方法之间建立关系,方法集可包含的方法数量不受限制,是一种封装功能和创建库代码的有效方式
                *   例:简单来说就是创建一个单独用来计算面积的方法集后,再去计算各种圆形就很方便了
                    *   比如
                        *   先声明一个type结构体Sphere,在声明两个func (s \*Sphere) 来分别计算周长与面积并返回给Sphere
                        *   然后要使用就可以直接输入圆的直径,便会直接输出圆的周长与面积了
            *   使用方法和指针
                *   使用这两的区别
                    *   一个是最基本的接收者参数,s Sphere的Sphere前加不加星号,不加为值,加为指针
                    *   另一个区别就是,方法接受的是一个值引用,原始结构体不受影响,而指针可以修改原始结构体的数据字段
                    *   需要修改原始结构体就用指针,需要操作结构体但不想影响到原始结构体就用值
            *   接口
                *   接口描述了方法集中的所有方法,并指定了每个方法的函数签名,而使用接口必须先实现它,满足了接口的要求便是实现
                    *   比如接口包含方法Power且函数签名相同,那么声明一个满足其要求也就是包含方法Power且方法函数签名与接口要求一致的方法集,而接口支持多种实现,不管是如何实现,
                    *   实现1: 满足要求
                        *   type T850 struct{ Name string}
                        *   func (r \*T850) PowerOn() error { return nil}
                    *   实现2:也满足要求
                        *   type R2D2 struct {Broken bool}
                        *   func (r \*R2D2) PowerOn() error {if r.Broken{return errors.New("未能启动")}else {return nil} }
                *   接口也是一种类型,可作为参数传递给函数,因此可编写重用于多个接口实现的函数
                    *   比如一个用来启动前面Robot的函数
                        *   func Boot(r Robot) error{ return r.PowerOn() }
                    *   这个函数接口Robot的实现作为参数并返回调用方法PowerOn的结果,可用于启动任何Robot,T850和R2D2都可以利用这个方法
                *   函数和方法的不同:方法多了个指定接收者的参数,能对数据类型调用方法
                *   可在接口的实现中添加额外方法,仅适用于结构体不适用于接口

