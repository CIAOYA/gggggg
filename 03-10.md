# 03-10

*   使用Goroutine(并行)

    *   理解并发

        *   并发(concurrent)

            *   一般程序是一次执行,顺序与出现顺序相同,干完这件事再去做下件事,例如先得把菜单给顾客,顾客才能点菜,但更复杂的情形,比如说从天气服务获取某个地方当前的天气,许多因素会影响响应返回的速度,因为响应速度无法预测所以每次都时间都不同,好比是餐馆里每个顾客都要点餐吃饭,无法同时为每个顾客配一个服务员,所以服务员可以并发的去执行任务,也就是厨师做菜时可以给其他顾客点餐,在其他顾客点餐时去取菜,也就是同时进行多个任务
    *   理解并发和并行(Goroutine)的区别&#x20;
        *   假设要烤100个烤肠
            *   并发:每次烤多个烤肠,但不能同时烤好所有的烤肠
            *   并行:用宿友的空气炸锅同时烤,进一步提升效率,烤好再放在一起
        *   并发就是一台饮水机两队人交替使用,不同于一般程序的顺序,即使最前面的人去上厕所了,另一队的人也能使用饮水机而不必一直等上厕所的人回来接水
            *   并行就是两个饮水机两队人同时使用两台饮水机
                *   但并行并不是并发子集,因为会出现处理的任务不可分步骤但环境是多核这种不能实现并发却能实现并行的情况
        *   并发和并行都可以是很多线程,区别在于能不能同时被多个cpu执行,可以就是并行,多个线程被一个cpu轮流切换执行就是并发
    *   Web理解并发
        *   网页的合成过程便是了,图片文字始终是有快有慢,但至少是多个任务都在执行,而不是所有请求执行完毕才加载网页
    *   阻塞和非阻塞代码
        *   模拟缓慢的函数调用可使用time.Sleep
            *   slowFunc内\:time.Sleep(time.Second \*2)
                *   使用了time.Sleep方法让程序暂停了2秒,暂停时不会执行其他代码
    *   Goroutine处理并发操作&#x20;
        *   go slowFunc()
            *   使用起来非常简单,让Goroutine执行的函数或方法前加上关键字go即可,看不到调用的结果是因为Goroutine立即返回,意味着执行后面的代码然后退出
    *   定义Goroutine
        *   Go在幕后使用线程管理并发,但Goroutine使你无须直接管理线程,创建一个Goroutine只需几kb的内存,因此创建数千个也不会耗尽内存,另外创建和销毁Goroutine的效率也非常高,因为Goroutine是一个并发抽象,所以无须准确的知道操作系统发生的情况
*   通道
    *   如果说Goroutine是一种支持并发编程的方式,那通道就是一种与Goroutine通信的方式,通道让数据能够进入离开Goroutine,方便之间通信
        *   "不要通过共享内存来通信,而通过通信来共享内存"
            *   其他语言中,并发编程通常通过在多个进程或线程之间共享内存实现,程序执行过程中可能会对共享内存加锁以禁止其他进程或线程修改,确保它只能被一个线程或进程访问,就像是防止一张70元的银行卡被同时持有的两人同时用掉50元一样,但锁的管理工作并非那么容易,所以通道就派上用场了
                *   同样是银行卡,通道会在持有人直接打开一个通信通道,让他们能够通信并采取相应的措施,比如一个交易可能向通道发送一条消息,而通道可能限制后续交易或另一个持有人的行为.
                    *   通过收发消息,使得能够以推送方式协调并发时间,事件发生时,可将触发的消息推送给接收者,使用共享内存时程序必须检查共享内存,在变化频繁的并发编程环境中,使用消息是一种更佳的通信方式
    *   通道的创建语法:
        *   c := make(chan string)
            *   使用内置函数make创建一个通道,由关键字chan指定,string指出这个通道用于储存字符串数据,只能收发字符串值
    *   向通道发送消息:
        *   c <- "hello"
            *   <-代表将右边的字符串发送给左边的通道,如果是string通道只能发字符串消息
    *   接受消息:
        *   msg := <-c
    *   使用通道进行通信:
        *   slowFunc函数中: time.Sleep(time.Second \*2)   c<- "slowFunc函数已完成"
            *   一如既往用暂停2秒阻塞代码测试Goroutine,并且向c通道发送了一句话
        *   main函数中: c := make(chan string)  go slowFunc()&#x20;
            *   创建了存储字符串数据的通道,使用了一个Goroutine执行函数slowFunc
        *   msg := <-c     fmt.Println(msg)
            *   声明变量msg接收通道c的消息,阻塞进程直到收到消息为止,避免过早退出,打印这条消息
    *   使用缓冲通道:
        *   一般收到消息就可直接发送给接收者,但如果没有接收者可将数据存储在通道中等待接收者准备就绪在给它
        *   创建缓冲通道可向内置函数make传递另一个表示缓冲区长度的参数:
            *   messages := make(chan string, 2) &#x20;
                *   2意味可存储两条消息,试着往里加两条
                    *   messages <- "电棍"		messages <- "山泥若"
            *   在存储完两条信息后,可用close方法关闭通道
                *   close(messages)
                    *   这时候可以打印一条消息来指出包含两条消息: fmt.Println("嘿,通道里面有两条消息呢"),然后再用阻塞代码休眠1秒
            *   这时候可以将通道作为参数传递给函数receiver
                *   函数receiver使用range迭代通道,并将通道中缓冲的消息打印到控制台
                *   例: receiver(messages)
    *   阻塞和流程控制
        *   有时需要让代码处于阻塞状态,比如需要在后台运行的程序需要阻塞保证不会退出,想让进程处于阻塞状态就得采用一些流程控制技巧了
            *   给通道指定消息接收者是一个阻塞操作,因为它将阻止函数返回,直到收到一条消息为止
                *   打印消息ping后退出,即在通道接收到消息后退出,需先创建一个函数,其接受(c chan string)
                    *   t := time.NewTicker(1\*time.Second)&#x20;
                        *   计时器,每格一秒输出一次,也就等于每次调用阻塞一秒
                    *   for{ c<- "ping"     <-t.C}
                        *   并循环
            *   如果在main函数中添加一条for语句,就能不断的接收消息并打印
                *   for{ msg := <-messages   fmt.Println(msg) }
            *   也可以指定迭代次数
                *   for i := 0;i<5;i++ {同上}
    *   将通道用作函数参数
        *   指定在函数中使用传入的通道,可在传递通道时将其指定为只读,只写或读写,这三语法差别不大就是了
        *   func channel(messages <- string) 只读和只写&#x20;
            *   只读
                *   msg := <-messages  fmt.Println(msg)&#x20;
            *   只写
                *   messages <- "hello world"
        *   func channel(messages chan string) 这是读写的函数语法
            *   msg := <-messages  fmt.Println(msg)   messages<-"基本就是上面两个加起来"
    *   使用select语句
        *   假设有多个Goroutine而程序将根据最先返回的执行相应操作,此时可使用select语句,为通道创建一系列接收者,并执行最先收到消息的接收者,和switch语句很像
            *   前置:创建了两个通道,创建向这两通道发送消息的函数,第一个函数休眠1s,第二个休眠2s,go执行函数,接下来用select创建两接收者看谁先收到消息:
                *   select {
                    *   case msg1 := <-channel1:&#x20;
                        *   fmt.Println("第一个case",msg1)
                    *   case msg2 := <-channel2:&#x20;
                        *   fmt.Println("第二个case",msg2) }
                *   如果从通道channel1收到消息将执行第一条case语句,channel2则第二条case,具体执行哪条取决于消息到达时间,谁先到谁执行.通常,接下来收到的其他消息将被休息,收到一条消息后select语句将不再堵塞
                *   因为第一条休眠1s比第二条快,所以第一条执行了,并且select语句就此结束
        *   select语句中同时从两个通道收到消息会随机选择并执行一条case语句,且只执行选中的case语句
    *   退出通道:
        *   在需要停止执行但不确定select语句何时返回可使用
            *   确定的话用定时器超时时间
        *   假如程序需要用select语句实现无限制阻塞,但同时能够随时返回,可在select语句中添加一个退出通道向退出通道发送消息结束该语句,从而停止阻塞;可将退出通道视为阻塞式select语句的开关,可随意命名,但通常是stop或quit
            *   例: 前置条件 \:messages := make(chan string)   stop := make(chan bool)
                *   for {
                    *   select {
                        *   case <- stop:
                            *   return
                        *   case msg := <- messages:
                            *   fmt.Println(msg)   }   }
                    *   无限制的阻塞,不断的接收消息,通过向stop发送消息,可方select停止阻塞
                *   可以创建一个读写函数,计时器计时每隔1s向通道发送一条消息
                    *   然后在main函数中创建一个go func在睡眠2秒后打印"起床"并向stop通道发送true,因为不发送就没完没了的运行了
                *   结果为:计时器发送了几条消息后,睡眠时间到了打印起床并结束运行
                *   关闭缓冲通道意味着不能再向它发送消息,缓冲的消息会被保留,可供接收者读取,也就是为什么可能会出现打印起床后还有一条消息

