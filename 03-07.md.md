# 3-7

*   函数
    *   函数接受输入并返回输出. 数据流经函数时将被变换
    *   结构:
        *   Go语言中,函数向编译器和程序员提供了有关的信息,这些信息指出函数将接受什么样的输入并提供什么样的输出.这类信息是在函数的第一行中提供的,而这一行被称为函数签名
        *   例:用关键字func指出这是一个函数的开头位置,然后是函数名,可根据函数名在其他地方调用或使用,接下来是一对括号指出接受什么样的值,括号后是返回值,返回值后的大括号里写函数体,如果函数签名声明了返回值,则函数体必须以终止语句结束.
            *   func 函数名 (x int,y int)int { 函数体 }&#x20;
            *   通常有一个返回值,但并非总是如此
    *   调用函数通过名称对其引用,并提供所需的参数
    *   定义不定参数函数
        *   不定参数函数是参数数量不确定的函数,代表接受可变数量的参数,在Go语言中能够传递可变数量的参数,但他们的类型必须与函数签名指定的类型相同,要指定不定参数,可使用3个点(...)
            *   例: func sumNumbers(numbers...int) int {&#x20;
                *   这个函数可接受一个或多个整数,可用来计算任意多个整数的和并返回单个整数
    *   具名返回值
        *   具名返回值能让函数在返回前将值赋给具名变量,提升函数的可读性,使其功能更加明确,在函数签名的返回值部分指定变量名
            *   例: func sayHi() (x,y string) {
                *   这个签名指定将返回两个值,并且都为string,还指定了变量名x和y,可在函数体中给它们赋值
                    *   括号内 x="电"  y="棍" return }
                        *   而在终止语句return前给具名变量进行赋值,使用具名返回值时无须显式地返回相应的变量,这被称为裸(naked) return语句
    *   递归函数
        *   不断调用自己直到满足特点条件的函数,要实现递归,可将调用自己的代码作为终止语句中的返回值
    *   函数作为值传递
        *   Go语言提供了一些函数式编程功能,将一个函数作为参数传递给其他函数,本质上说Go将函数视为一种类型,因此可将函数赋给变量,以后再通过变量调用它们.
            *   例:将一个函数赋给变量fn
                *   func main(){ fn:= func () { fmt.Println("function called")}  fn() }
                    *   使用简短变量赋值运算符将一个函数赋给了变量fn
                    *   声明了这个函数并将其定义为打印一行文本,让你知道它被调用了
                    *   在变量fn后使用()调用这个函数
*   控制流程
    *   if 语句
        *   可依次运行多条if语句,运行顺序与出现顺序相同
    *   else语句
        *   不做判断,到达所在分支就执行
    *   else if语句
        *   依次判断多个布尔表达式
    *   比较运算符
        *   \== != < <= > >=
    *   算术运算符&#x20;
        *   \+ - \* /  %
    *   逻辑运算符
        *   && 与:两个条件为true
        *   || 或:两个条件是否至少一个为true
        *   ! 非:条件是否为false
    *   switch语句
        *   代替冗长的if else布尔比较,更简洁,还支持在其他case条件都不满足时将执行的default case.可使用关键字default指定其他case条件都不满足时要执行的代码,通常放在switch语句末尾,但也可以放在其他任何地方
            *   例 switch i { case1: fmt.Println("一") case2......default: fmt.Println("这不是个位数")}
            *   表达式结果相等就执行,不等就跳到下一条
    *   for循环

        *   反复执行代码块,直到条件不再满足
            *   例\:i :=0  for i <10 { i++ fmt.Println(i)}
                *   初始化 判断 每次循环+1 直到不小于10循环结束

        *   包含初始化语句和后续语句的for语句
            *   初始化语句:仅在首次迭代前执行
            *   条件语句:每次迭代前都将检查的布尔表达式
            *   后续雨具:每次迭代后都将执行

        *   包含range子句的for语句
            *   遍历数据结构
            *   例
                *   numbers := \[] int {1,2,3,4}  for i,n := range numbers {打印i语句 打印n语句}
                    *   声明遍历numbers,并将一个包含4个整数的数组赋给它
                    *   指代迭代变量i,用于索引值,迭代结束后更新
                    *   指定迭代变量n,存储来自数组的值,迭代结束后更新
                    *   循环中打印这两个变量
    *   defer语句
        *   defer能用让你在函数返回前执行另一个函数,函数在遇到return语句或达到函数末尾时返回,defer语句通常用于执行清理操作或确保操作(如网络调用) 完成后再执行另一个函数
            *   例:
                *   defer fmt.Println("我是1") fmt.Println("sb")
                    *   使用一条defer语句,在它所在的函数执行完毕后执行另一个函数
                    *   向终端打印sb,外部函数就此结束
                    *   外部函数结束后,执行defer语句指定的函数
                    *   也就是 sb 执行结束 我是1
            *   多条defer语句,按出现顺序相反的顺序执行
            *   defer fmt.Println("我是1") defer fmt.Println("我是2") defer fmt.Println("我是3") fmt.Println("sb")
                *   也就是 sb 执行结束 我是3 我是2  我是1&#x20;
*   数组、切片和映射
    *   数组
        *   声明数组 var cheeses \[2] string   名为cheeses的长度为2的字符串类型数组
            *   索引从0开始,遍历习惯用长度-1
    *   切片
        *   底层数组中的一个连续片段,通过它可以访问该数组中一系列带编号的元素,比数组更灵活,可在切片中添加删除复制元素,轻量级的数组包装器,既保留了数组的完整性又比数组使用起来更容易
        *   声明切片 var cheeses = make ( \[] string,2) 使用Go内置函数make创建的长度为2的空切片,其中第一个参数为数据类型,第二个参数为长度,意味切片包含两个字符串元素并赋给变量cheeses
        *   赋值与打印跟数组一样
            *   cheeses\[0] = "哈"     fmt.Println(cheeses\[0])
        *   添加元素 :可用内置函数append并可添加很多值,会相应的调整切片长度,并将指定的值赋给新创建的元素
            *   cheeses = append(cheeses,"依托","脱衣","一坨")
        *   删除元素: 也可使用append
            *   cheeses = append(cheeses\[:2],cheeses\[2+1:]...)
                *   删除了第三个也就是索引2的元素
        *   复制元素
            *   在赋值切片中的元素前,必须再声明一个类型与该切片相同的切片,因为不能直接将字符串切片中的元素复制到整数切片中,但不需要长度一致
            *   copy(六耳猕猴切片,齐天大圣切片)
    *   映射
        *   数组和切片可通过索引值访问的元素集合,而映射是通过键访问的无序元素编组,一眼丁真,鉴定为键值对集合
        *   声明创建空映射
            *   var players = make(map \[string] int)
                *   Go语言内置函数make创建一个键类型为字符串,值类型为整数的映射并赋给变量players
        *   添加键值对
            *   players\["三十二"] = 32&#x20;
                *   变量名后方括号内为键,等号右边是值
                *   打印映射中特点键对应的值,可使用键获取
                    *   fmt.Println(players\["三十二"])
        *   删除元素,用内置函数delete
            *   delete(players,"三十二")

