# &#x20;03-09

*   使用字符串&#x9;

    *   创建字符串字面量
        *   Go语言支持两种创建字符串字面量的方式
            *   解释型字符串字面量是双引号括起的字符,如"电棍",除了换行符和未转义双引号可包含其他任何字符,反斜杠\a\b\f\n\r\t\v这类在rune字面量解读
                *   rune字面量
                    *   在解释型字符串字面量内使用的字面量,可以在字符串内对字符进行换行,退格换页之类的操作
            *   原始字符串字面量用反引号(不是单引号是波浪键那个)括起,如\`电棍\`,反斜杠没有任何意义,原样解释也就是打什么输出什么,包括回车空格反斜杠
    *   拼接字符串
        *   要拼接合并字符串,可将运算符+用于字符串变量,使用解释型还是原始型无关紧要
        *   两个例子
            *   s := "电棍"+"是我叠?"
            *   s := "电棍"   s +="是我叠"
        *   只能拼接字符串的变量,除非将其他类型转为字符串

            *   比如把int转string使用strconv.Itoa(i)
    *   缓冲区拼接字符串

        *   简单而少量的拼接,用+和+=效果虽然很好,但复杂的还是效率太低了,比如循环,用空的字节缓冲区来拼接效率更高

            *   例: for i := 0; i<500; i++ { buffer.WriteString("z") } 最后输出buffer.string()也就是以字符串的方式输出结果
    *   理解字符串

        *   编码,Go语言支持UTF-8和国际字符集,字符串实际上就是字节切片,意味可以像操作其他字节切片一样操作字符串
        *   Go语言支持UTF-8,意味着函数和方法的名称可包含UTF-8支持的任何字符,当然还是用英语好些
    *   处理字符串

        *   给字符串变量赋值后就能用strings包里的函数来处理字符串了

            *   字符串转小写\:strings.ToLower()
            *   字符串找子串\:strings.Index()  注:第二个参数是要查找的子串,没有返回-1.索引从0开始
            *   删除字符串中的空格\:strings.TrimSpace()
        *   创建字符串后不能进行修改,重新声明变量会导致编译错误,但可使用符合赋值运算符+=来拼接字符串
*   处理错误

    *   使用函数ioutil.Readfile

        *   接受一个字符串参数并返回一个字节切片和一个错误值,
        *   定义\:func ReadFile(filename string) (\[]byte,error)

            *   例\:file,err := ioutil.ReadFile("foo.txt")    if err != nil {fmt.Println(err) return}

                *   检查foo文本,将方法ReadFile的返回值存储到两个变量

                    *   意味着总是返回一个错误值,让你对其检查

                        *   比如\:go run example01.go
                        *   open foo.txt: no such file or directory

                            *   使用ReadFile函数读取文件
                            *   如果有错误,意味返回的错误值不为nil
                            *   打印错误,程序就此结束
                            *   没有错误,则打印文件内容
        *   Go语言中,有一种约定是,如果没有发生错误,返回的错误值将为nil,可以检查方法或函数是否像预期那样执行完毕,虽然有人觉得麻烦,但Go语言处理错误更为灵活,可像其他类型一样在函数之间传递错误,代码要简短的多.
    *   理解错误类型

        *   Go语言中,错误是一个值,标准库声明了接口error

            *   type error interface {Error() string}

                *   这个接口只有一个方法Error,返回一个字符串
    *   创建错误

        *   errors包支持创建和操作错误

            *   err := errors.New("Something went wrong")   if err != nil{fmt打印err}

                *   就会返回一个所在的go文件名称和Something went wrong

                    *   使用errors包的方法New创建一个错误
                    *   用if语句检查这个错误值是否为nil
                    *   如果不为nil,就打印出来
    *   设置错误的格式

        *   方法ErrorF用于设置返回的错误字符串的格式,能够将多个值合并成更有意义的错误字符串,动态的创建错误字符串

            *   err := fmt.Errorf("The %v %v quit", role, name)
    *   函数中返回错误

        *   Go语言做法就是从函数和方法中返回一个错误值,而处理错误不是在函数中是在调用函数的地方进行,提供了极大的灵活性,而不是一刀切

            *   函数Half:

                *   func Half(numberToHalf int )(int,error){if numberToHalf%2 !=0{return -1,fmt.Errorf("Cannot half %v",numberToHalf)} return numberToHalf / 2,nil }

                    *   检查是否为偶数,使用了求模(%求余)运算符,返回余数,奇数返回-1和错误代码,偶数则返回结果和nil
            *   函数main内:

                *   n,err := Half(19)

                    *   将整数19给函数Half
                *   if err != nil{ fmt.Println(err)return}

                    *   未返回nil,也就是出现错误则打印错误
        *   错误和可用性

            *   编写供他人使用的库或包时,编写和使用错误的方式将极大地影响可用性
            *   所以别写的只有自己看的懂
        *   慎用panic

            *   panic是Go语言的一个内置函数,终止正常点控制流程并引发恐慌导致程序停止执行,出现普通错误时不提倡这种做法,绝无回旋余地!
            *   使用方法就是在输出函数中(常用main函数)

                *   panic("哦我的朋友,这程序寄了"),这条代码后面的代码都不会执行了
        *   小贴士:虽然 if err != nil 随处可见,看起来太重复了,但这确实是最好的方法,因为能随心所欲的处理错误,并且要关心错误

